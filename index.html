<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>My GitHub Pages Site</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 2rem;
      color: #fff;
      background: radial-gradient(circle at 50% 50%, #ff00ff, #00ffff, #ffff00, #ff00ff);
      background-size: 400% 400%;
      animation: psychedelic-bg 20s linear infinite;
    }

    @keyframes psychedelic-bg {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    header {
      text-align: center;
    }
    #cube-container {
      width: 100%;
      height: 400px;
      margin-top: 20px;
    }
      /* GUI and stats are added via scripts */
  </style>
</head>
<body>
  <header>
    <h1>Welcome to My GitHub Pages Site</h1>
  </header>
  <main>
    <p>This is a simple website served with GitHub Pages.</p>
  </main>
      <div id="cube-container"></div>

      <section id="readme">
        <h2>Website</h2>
        <p>This repository contains a minimal website that can be hosted using GitHub Pages.</p>
        <h3>Getting Started</h3>
        <ol>
          <li>Clone the repository.</li>
          <li>Enable GitHub Pages in the repository settings, using the main branch.</li>
          <li>Visit the generated GitHub Pages URL to see the site. The page loads <code>three.js</code> modules directly from GitHub so it works even if CDNs like <strong>unpkg</strong> are blocked.</li>
        </ol>
        <p>The main content is in <code>index.html</code>. An <strong>Enter AR</strong> button is provided by <code>three.js</code> to start and exit the AR session. Use the <strong>Enable light estimation</strong> checkbox to choose whether light estimation will be used before entering AR.</p>
        <h3>Requirements</h3>
        <p>This site ships with <strong>three.js r128</strong> and requires a browser capable of WebXR's AR features (e.g. Chrome on Android). DOM overlay is used to display the HUD and performance stats while in AR. Make sure your browser supports this optional feature. For the best experience, use a mobile device that supports AR and ensure WebXR is enabled.</p>
      </section>

    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.128.0/build/three.module.js';
      import { ARButton } from 'https://unpkg.com/three@0.128.0/examples/jsm/webxr/ARButton.js';
      import Stats from 'https://unpkg.com/three@0.128.0/examples/jsm/libs/stats.module.js';
      import { GUI } from 'https://unpkg.com/three@0.128.0/examples/jsm/libs/dat.gui.module.js';

    const container = document.getElementById('cube-container');

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera();
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.xr.enabled = true;
    container.appendChild(renderer.domElement);

    const stats = new Stats();
    document.body.appendChild(stats.dom);
    stats.dom.style.display = 'none';

    // Simple Web Audio context for tone generation
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    function playTone(type, frequency) {
      const osc = audioCtx.createOscillator();
      osc.type = type;
      osc.frequency.value = frequency !== undefined ? frequency : 220 + Math.random() * 440;
      osc.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.5);
    }

    // Add AR button to start the AR session with DOM overlay
    container.appendChild(ARButton.createButton(renderer, {
      requiredFeatures: ['hit-test', 'dom-overlay'],
      domOverlay: { root: document.body }
    }));

    // Reticle used for hit testing - replaced with a transparent cube
    const reticle = new THREE.Mesh(
      new THREE.BoxGeometry(0.1, 0.1, 0.1),
      new THREE.MeshBasicMaterial({ color: 0x00ff00, opacity: 0.25, transparent: true })
    );
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    // Controller to handle user input
    const controller = renderer.xr.getController(0);
    controller.addEventListener('select', onSelect);
    scene.add(controller);

    let hitTestSource = null;
    let hitTestSourceRequested = false;

    const cubes = [];
    let objectCounter = 0;

    // Slider state for collision threshold
    const threshold = { xz: 0.15, y: 0.15 };

    const detectionSphereRadius = 0.1;
    const detectionSphere = new THREE.Mesh(
      new THREE.IcosahedronGeometry(detectionSphereRadius, 2),
      new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, opacity: 0.3, transparent: true })
    );
    camera.add(detectionSphere);
    updateDetectionSphere();

    const gui = new GUI();
    gui.domElement.style.display = 'none';
    gui.add(threshold, 'xz', 0.05, 0.45).onChange(updateDetectionSphere);
    gui.add(threshold, 'y', 0.05, 0.45).onChange(updateDetectionSphere);

    function createLightning(start, end) {
      const segments = 20;
      const points = [];
      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const pos = new THREE.Vector3().lerpVectors(start, end, t);
        if (i !== 0 && i !== segments) {
          pos.x += (Math.random() - 0.5) * 0.05;
          pos.y += (Math.random() - 0.5) * 0.05;
          pos.z += (Math.random() - 0.5) * 0.05;
        }
        points.push(pos);
      }
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
      return new THREE.Line(geometry, material);
    }

      function onSelect() {
          if (reticle.visible) {
            let geometry;
            let waveType;
            let frequency;
            const r = Math.random();
            if (r < 0.33) {
              geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
              waveType = 'square';
            } else if (r < 0.66) {
              geometry = new THREE.TetrahedronGeometry(0.1);
              waveType = 'sawtooth';
            } else {
              geometry = new THREE.IcosahedronGeometry(0.1);
              waveType = 'sine';
            }
            const material = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
            const cube = new THREE.Mesh(geometry, material);
            const shadow = new THREE.Mesh(
              new THREE.CircleGeometry(0.07, 32),
              new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.25, transparent: true })
            );
            shadow.rotateX(-Math.PI / 2);
            shadow.position.y = -0.051;

            const group = new THREE.Group();
            group.add(cube);
            group.add(shadow);
            const overlay = new THREE.Mesh(
              new THREE.BoxGeometry(0.2, 0.2, 0.2),
              new THREE.MeshBasicMaterial({ color: 0x0000ff, opacity: 0.1, transparent: true })
            );
            group.add(overlay);
            group.position.setFromMatrixPosition(reticle.matrix);

            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '48px sans-serif';
            ctx.fillText(String(objectCounter + 1), 32, 32);
            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false });
            const label = new THREE.Sprite(labelMaterial);
            label.scale.set(0.15, 0.15, 0.15);
            group.add(label);

            frequency = 220 + Math.random() * 440;
            group.userData = { waveType, frequency, overlay, mesh: cube, inside: false, label };

            if (cubes.length > 0) {
              const last = cubes[cubes.length - 1];
              const line = createLightning(last.position, group.position);
              scene.add(line);
            }

            cubes.push(group);
            scene.add(group);
            objectCounter++;
          }
      }

    renderer.setAnimationLoop(function (timestamp, frame) {
      if (frame) {
        const referenceSpace = renderer.xr.getReferenceSpace();
        const session = renderer.xr.getSession();

        if (!hitTestSourceRequested) {
          session.requestReferenceSpace('viewer').then(function (refSpace) {
            session.requestHitTestSource({ space: refSpace }).then(function (source) {
              hitTestSource = source;
            });
          });
          session.addEventListener('end', function () {
            hitTestSourceRequested = false;
            hitTestSource = null;
          });
          hitTestSourceRequested = true;
        }

      if (hitTestSource) {
        const hitTestResults = frame.getHitTestResults(hitTestSource);
        if (hitTestResults.length) {
          const hit = hitTestResults[0];
          const pose = hit.getPose(referenceSpace);
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
        } else {
          reticle.visible = false;
        }
      }
    }

    // Check if camera enters any overlay cubes to trigger sounds
    // The detection region can be adjusted using the GUI
    cubes.forEach(g => {
      g.userData.label.quaternion.copy(camera.quaternion);
      const box = new THREE.Box3().setFromObject(g.userData.overlay);
      const expandVec = new THREE.Vector3(threshold.xz, threshold.y, threshold.xz);
      box.expandByVector(expandVec);
      const inside = box.containsPoint(camera.position);
      if (inside && !g.userData.inside) {
        playTone(g.userData.waveType, g.userData.frequency);
        g.userData.inside = true;
        const mat = g.userData.mesh.material;
        const originalColor = mat.color.getHex();
        const id = setInterval(() => mat.color.set(Math.random() * 0xffffff), 100);
        setTimeout(() => {
          clearInterval(id);
          mat.color.setHex(originalColor);
        }, 500);
      } else if (!inside && g.userData.inside) {
        g.userData.inside = false;
      }
    });

    renderer.render(scene, camera);
    stats.update();
  });

    function onWindowResize() {
      renderer.setSize(container.clientWidth, container.clientHeight);
    }

      window.addEventListener('resize', onWindowResize);

      const header = document.querySelector('header');
      const main = document.querySelector('main');
      renderer.xr.addEventListener('sessionstart', () => {
        header.style.display = 'none';
        main.style.display = 'none';
        stats.dom.style.display = '';
        gui.domElement.style.display = '';
      });
      renderer.xr.addEventListener('sessionend', () => {
        header.style.display = '';
        main.style.display = '';
        stats.dom.style.display = 'none';
        gui.domElement.style.display = 'none';
      });

      // Display version info in the console
      console.log(`three.js r${THREE.REVISION}`);

      function updateDetectionSphere() {
        const radius = detectionSphereRadius + Math.max(threshold.xz, threshold.y);
        detectionSphere.scale.setScalar(radius / detectionSphereRadius);
      }
    </script>
  </body>
</html>
